using System;
using System.Collections.Generic;
using System.IO;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;

public class MultiThreadedDownloader
{
    private const int BufferSize = 8192;

    public static async Task DownloadFile(string url, string destinationPath)
    {
        using (var httpClient = new HttpClient())
        {
            long fileSize = await GetFileSize(httpClient, url);
            long threads = Environment.ProcessorCount;
            double rangeSize = Math.Ceiling((double)fileSize / threads);

            List<Task> tasks = new List<Task>();
            for (int i = 0; i < threads; i++)
            {
                double startRange = i * rangeSize;
                double endRange = (i == threads - 1) ? fileSize - 1 : (i + 1) * rangeSize - 1;

                tasks.Add(DownloadRange(httpClient, url, destinationPath, startRange, endRange));
            }

            await Task.WhenAll(tasks);
        }
    }

    private static async Task DownloadRange(HttpClient httpClient, string url, string destinationPath, double startRange, double endRange)
    {
        while (true)
        {
            try
            {
                using (var response = await httpClient.GetAsync(url, HttpCompletionOption.ResponseHeadersRead))
                {
                    response.EnsureSuccessStatusCode();

                    using (var inputStream = await response.Content.ReadAsStreamAsync())
                    using (var outputStream = new FileStream(destinationPath, FileMode.OpenOrCreate, FileAccess.Write, FileShare.Write))
                    {
                        var buffer = new byte[BufferSize];
                        int bytesRead;
                        try
                        {
                            while ((bytesRead = await inputStream.ReadAsync(buffer, 0, BufferSize)) > 0)
                            {
                                await outputStream.WriteAsync(buffer, 0, bytesRead);
                            }
                        }
                        catch (IOException e)
                        {
                            if (e.Message == "从传输流收到意外的 EOF 或 0 个字节。") break;
                        }
                    }
                }
            }
            catch
            {

            }
        }
    }

    private static async Task<long> GetFileSize(HttpClient httpClient, string url)
    {
        var request = new HttpRequestMessage(HttpMethod.Head, url);
        using (var response = await httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead))
        {
            response.EnsureSuccessStatusCode();
            return response.Content.Headers.ContentLength ?? 0;
        }
    }
}
